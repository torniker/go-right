# How to Go Right
ვინც წინა devfest-ზე იყო ქუთაისში იმედია გახსოვთ რომ ვილაპარაკე იმაზე თუ რატომ უნდა წავიდეთ? Why Go? 
დღეს ვეცდები გაჩვენოთ როგორ წავიდეთ მარჯვნივ?
ალბათ მიხვდით, რომ მოწოდებით ენათმეცნიერი ვარ და თარგმანში ვიკარგები...
ხო, როგორ უნდა წავიდეთ მარჯვნივ? 
> აქ ისმის შეკითხვა, ცაციებმა რა ვქნათ? თქვენ თუ გინდათ მარცხნივ წადით და შემდეგ devfest-ზე მოგვიყევით იქ რა იპოვეთ. პუტინს ნუ გაყვებით და სადაც გინდათ იქ წადით.
კიდევ როგორ შეიძლება ითარგმნოს ეს ფრაზა - How to Go Right?
როგორ წავიდეთ სწორად?
მოკლედ მოდი ვისაუბროთ იმაზე როგორ დავწეროთ კოდი Go-ზე "სწორად".

სანამ სერიოზულად დავიწყებთ ლაპარაკს, ენის გასატეხები ვის უყავრს? თქვენთვის მაქვს საჩუქარი: 
- Wright write right code with right hand from left to right?
## Disclaimer
მოცემული სოლუშენი, მაგალითები და საერთოდ ყველაფერი არის სისულელე და არ ნიშნავს რომ ესაა სწორი გზა, სათაურია უბრალოდ ეგეთი. 
ყოველთვის ეცადეთ იპოვოთ უკეთესი, გააუმჯობესოთ არსებული.

იურიდიული ფორმალობებიც მოვიშორეთ...
## How Deep Does the Gopher Hole Go?
თანამედროვე სამყაროში, რაც უფრო ვითარდება ტექნოლოგიები და ხდება საყოველთაო, მით უფრო იზრდება მოთხოვნა სოფტვეარზე და პროდუქტებიც უფრო და უფრო კომპლექსური და რთული ხდება. 
როგორი ბანალური წინადადება იყო. თუმცა არის მასში სიმართლის მარცვალი.
ხოდა რაც უფრო გაიზარდა და გართულდა მოთხოვნები, პროგრამისტებმა ვცადეთ რომ კოდის წერის უკეთესი გზები და მეთოდები გვეპოვნა.
პირველი ნაბიჯები ამ მიმართულებით GoF-მა (Gang of Four) გადადგა, 1994 წელს გამოცემული წიგნით `Design Patterns`. მას მერე ვცდილობთ pattern-ების პოვნას რომელიც უკეთ მოერგება პროდუქტის მოთხოვნებს, გუნდის ზომას და კიდევ ბევრ სხვა რამეს. ალბათ გსმენიათ SOLID პრინციპებზე, DRY-ზე, KISS-ზე, YAGNI-ზე და ა.შ. ეს ყველაფერი სწორად ზემოთ ხსენებულს ემსახურება.
ყველაფერ სიკეთესთან ერთად Go შეიქმნა სწორად ამ პრობლემების მოსაგვარებლად. 
ჩემს და Go-ს ურთიერთობაზე ბევრს აღარ ვილაპარაკებ, ისედაც იმაზე მეტი გაგანდეთ წინაზე ვიდრე საჭირო იყო...
ახლა მინდა მოგიყვეთ რას მივაგენი, როცა ორმოებს ვთხრიდი და მიწისქვეშა გვირაბები გამყავდა, როგორც ჭეშმარიტ gopher-ს.
## Drill Down
პირველ რიგში კიდევ ერთი Disclaimer: რასაც ვილაპარაკებ ყველაფერს არ ერგება, ეს პრინციპები ძირითადად საშუალო ზომის პროექტებზე მუშაობს. პატარა იქნება ალბათ რამდენიმე გვერდიანი საიტი და დიდი google.com, amazon.com და მსგავსები, ყველაფერი მათ შორის შეგვიძლია საშუალო ზომის პროექტად ჩავთვალოთ... ასე რომ საკმაოდ დიდია ბაზარი სადაც შეგიძლიათ ამ მიდგომების გამოყენება...
## Go Deeper
თანამედროვე სოფტვეარის შექმნისას ავტომატურად გვეფიქრება მიკრო სერვისებზე და კოდის თუ ბიზნეს ლოგიკის ისე განაწილებაზე რომ მინიმალური იყოს მათ შორის დამოკიდებულება (dependecy)... 
ვინმეს თუ აგიწყვიათ სისტემა მიკრო სერვისებით გეცოდინებათ რომ პლიუსებთან ერთად ბევრი მინუსიც აქვს. როგორც წესი პროექტის კეთებისას გუნდების და მიკროსერვისების რაოდენობა ერთმანეთს არ ემთხვევა (at least პირველ ეტაპზე) და ერთ გუნდს უწევს რამდენიმე მიკრო სერვისის დეველოპმენტ / მეინთენენსი. მიკრო სერვისებზე რო ვფიქრობთ ვცდილობთ მაქსიმალურად დავაცალკევოთ ისინი ერთმანეთისგან და გავხადოთ დამოუკიდებლები. ვქმნით ხოლმე ცალ-ცალკე რეპოებს მათთვის და ცალკე რეპოებს მათი საერთო დეპენდესებისთვის, მშრალებიც (DRY) რომ ვიყოთ. ამ ყველაფრის მართვას მივყავართ დიდი თავის ტკივილთან და მერე ვამბობთ რომ მიკროსერვისები არ ვარგა, ცუდია და არა პრაქტიკულია.
წარმოვიდგინოთ რომ გვაქვს მიკროსერვისები და ცალ-ცალკე რეპოების მართვა არ გვიწევს. ამ შემთხვევაში ბევრად ეფექტური ხდება დეველოპმენტიც და მეინთენანსიც. წარმოვიდგინოთ რომ ცალ-ცალკე ბაზის სერვერს ყველა მიკროსერვისს არ ვუქმნით, ესეც დიდი პლიუსია დროის და რესურსის დასაზოგად. მოკლედ ახლა წარმოგიდგენთ პროექტს რომელიც მიკრო სერვისების და მონოლითური პროექტის რაღაცნაირი ჰიბრიდია და საშუალო ზომის პროექტებისთვის მგონია რომ ძალიან პრაქტიკულია ესეთი მიდგომა.
ანუ ჩვენი მიზანია რომ ისეთი პროექტის სტრუქტურა / არქიტექტურა გვქონდეს სადაც ადვილია ზრდა და ამავე დროს დეველოპმენტი და მეინთენენსი არაა თავის ტკივილი
- Go Deeper
- Go Faster
- Go Harder


